<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Homer Graph Visualization</title>

  <!-- D3.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body { margin: 0; }
    .canvas-container { width: 100vw; height: 100vh; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body onload="responsiveCanvasSizer(); fetchAndRender();">
  <div class="canvas-container"><canvas></canvas></div>

  <script>
    const API_BASE = 'https://an-leabharlann-ghealach.onrender.com';
    const token = localStorage.getItem('token'); // assume present

    const circleSize = 30;
    const arrowHeight = 5;
    const arrowWidth = 5;

    let nodeItemMap = {};
    let linkItemMap = {};

    // Resize canvas for high DPI
    function responsiveCanvasSizer() {
      const canvas = document.querySelector('canvas');
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
    }

    async function fetchAndRender() {
        // Fetch Author Homer with relations
        const title = 'Aided Con Culainn';
        const res = await fetch(
            `${API_BASE}/texts/${encodeURIComponent(title)}`,
            { headers: { 'Authorization': `Bearer ${token}` } }
        );
        /*const res = await fetch(`${API_BASE}/authors/Anonymous`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });*/
        const data = await res.json();

      // Build nodes: the author itself
      nodeItemMap = {};
      linkItemMap = {};

      // Helper to add node
      function addNode(obj) {
        const key = obj.id;
        if (!nodeItemMap[key]) {
          nodeItemMap[key] = {
            id: key,
            labels: data.labels,
            properties: data.properties
          };
        }
      }

      // Actually add the author node
      addNode({ id: data.id });

      // Process outgoing relations
      data.outgoingRels.forEach(r => {
        const target = r?.node;
        if (target?.id != null) {
          const relKey = r.id;
          // add target node only if valid
          nodeItemMap[target.id] = {
            id:         target.id,
            labels:     [target.label || ''],
            properties: { name: target.name || '' }
          };
          // add link
          linkItemMap[relKey] = {
            id:     relKey,
            source: data.id,
            target: target.id,
            type:   r.type || ''
          };
        }
      });

      // Process incoming relations
      data.incomingRels.forEach(r => {
        const source = r?.node;
        if (source?.id != null) {
          const relKey = r.id;
          nodeItemMap[source.id] = {
            id:         source.id,
            labels:     [source.label || ''],
            properties: { name: source.name || '' }
          };
          linkItemMap[relKey] = {
            id:     relKey,
            source: source.id,
            target: data.id,
            type:   r.type || ''
          };
        }
      });

      updateGraph(Object.values(nodeItemMap), Object.values(linkItemMap));
    }

    // D3 force simulation and drawing
    function updateGraph(nodes, links) {
        const canvas = document.querySelector('canvas');
        const width = canvas.width;
        const height = canvas.height;
        let transform = d3.zoomIdentity;

        const linkForce = d3.forceLink()
            .id(d => d.id)
            .distance(300)
            .links(links);

        const simulation = d3.forceSimulation(nodes)
            .force('link', linkForce)
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width/2, height/2))
            .force('collide', d3.forceCollide(circleSize*1.5))
            .on('tick', render);

        d3.select(canvas).call(d3.zoom()
            .scaleExtent([0.1, 5])
            .on('zoom', ({transform: t}) => { transform = t; render(); })
        );

        function render() {
            const ctx = canvas.getContext('2d');
            ctx.save();
            ctx.clearRect(0,0,width,height);
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.k, transform.k);

            // draw links as arrows with labels
            links.forEach(d => {
                const sx = d.source.x;
                const sy = d.source.y;
                const tx = d.target.x;
                const ty = d.target.y;

                // unit vector from source â†’ target
                const dx = tx - sx;
                const dy = ty - sy;
                const dist = Math.hypot(dx, dy);
                const ux = dx / dist;
                const uy = dy / dist;

                // shorten line so it doesn't overlap node circles
                const startX = sx + ux * circleSize;
                const startY = sy + uy * circleSize;
                const endX   = tx - ux * circleSize;
                const endY   = ty - uy * circleSize;

                // draw main line
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // compute arrowhead points
                const leftX  = endX - uy * arrowHeight - ux * arrowWidth;
                const leftY  = endY + ux * arrowHeight - uy * arrowWidth;
                const rightX = endX + uy * arrowHeight - ux * arrowWidth;
                const rightY = endY - ux * arrowHeight - uy * arrowWidth;

                // draw arrowhead
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(leftX, leftY);
                ctx.lineTo(rightX, rightY);
                ctx.closePath();
                ctx.fillStyle = '#666';
                ctx.fill();

                // draw rotated label at midpoint, correcting for upside-down text
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                let angle = Math.atan2(endY - startY, endX - startX);
                if (Math.abs(angle) > Math.PI / 2) { // Flip label text if it appears upside-down
                    angle += Math.PI;
                }

                const labelOffset = 8;  // move label 8px above the line

                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(angle);
                ctx.font = '12px sans-serif';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // draw text slightly above the line (negative y in rotated space)
                ctx.fillText(d.type || '', 0, -labelOffset);
                ctx.restore();
            });

            // draw nodes with dynamic radii to fit their labels
            nodes.forEach(d => {
                const ctx = canvas.getContext('2d');
                const label = d.properties.name || d.properties.title || d.id;

                // set font before measuring
                ctx.font = '12px sans-serif';
                const textMetrics = ctx.measureText(label);
                const textWidth  = textMetrics.width;
                const textHeight = 12; // approximate font-size in px

                // compute radius: enough to fit label + padding
                const padding = 8;
                // take the larger of half the text width or half the text height
                const r = Math.max(circleSize, Math.max(textWidth / 2, textHeight / 2) + padding);

                // draw circle with computed radius
                ctx.beginPath();
                ctx.arc(d.x, d.y, r, 0, 2 * Math.PI);
                ctx.fillStyle = '#6df1a9';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                // draw label
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, d.x, d.y);

                ctx.closePath();
            });
            ctx.restore();
        }
    }
  </script>
</body>
</html>
